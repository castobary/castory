{"title":"Analyzing Book Reviews","markdown":{"yaml":{"title":"Analyzing Book Reviews","author":"Castory Munishi","format":{"html":{"theme":"united","code-fold":true,"code-tools":true}},"date":"10/25/2022","editor":"visual","toc":true},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\nYou work for a company selling books about learning programming. Your company has produced multiple books, and each has received many reviews. Your company wants us to check out the sales data and see if we can extract any useful information from it. You wil analyze the book_reviews dataset to answer company's important questions.\n\n*Objective of the Analysis*\n\nOur main goal is to figure out **what book is the most profitable**. How will we judge what the \"most profitable\" book is though? Our dataset represents customer purchases. One way to define \"most profitable\" might be to just choose the book that's purchased the most. Another way to define it would be to see how much money each book generates overall.\n\n## Task One\n\n-   Import the dataset\n\n-   Use the `dim()` to find the number of rows and columns\n\n-   Use the `colnames()` to determine the names of the columns in the dataset and take a moment to reflect on what each represents\n\n-   Use a for loop to check column types using `typeof()` function\n\n-   check for unique values using the `unique()`\n\n-   Try yourself first, the press Click Me to see solution!\n\n<details>\n\n<summary>Click Me!</summary>\n\n<p>\n\n*Code for importing the dataset and checking dimensions!*\n\n```{r}\n#| message: false\n#| echo: true\npacman::p_load(\n  readr,\n  dplyr,\n  magrittr\n)\n\nds <- read_csv(\"book_reviews.csv\")\n\ndim(ds)\n\ncolnames(ds)\n```\n\n-   Printing data types using a for loop\n\n```{r}\n for (i in colnames(ds)) {\n   print(typeof(ds[[i]]))\n   \n }\n```\n\n-   Printing unique values for each data type\n\n```{r}\nfor (i in colnames(ds)) {\n  print(unique(ds[[i]]))\n}\n```\n\n</p>\n\n</details>\n\n## Task Two\n\n-   Create a new dataset by removing all rows with `NA`\n-   Check the dimensions of the new cleaned dataset\n\n```{r}\nds <- ds %>%\n  filter(!is.na(review))\ndim(ds)\n```\n\n## Task Three\n\n-   Labels in the state column are inconsistent \"CA\" and California\n-   Make all labels consistent using the mutate function\n\n```{r}\nds <- ds %>%\n  mutate(state_clean = case_when(state %in% \"CA\" ~ \"California\",\n                                  state %in% \"NY\" ~ \"New York\",\n                                  state %in% \"TX\" ~ \"Texas\",\n                                  state %in% \"FL\" ~ \"Florida\",\n                                  TRUE ~ state))\n\nds %>% pull(state_clean) %>% unique()\n```\n\n## Task Four\n\na)  Using the `mutate()` function create a new column in the dataset called review_num. It should take the original review column and convert it into a numerical form. The column should be coded as following:\n\n-   The `case_when()` function might be useful here since we know how each of the reviews should be reclassified into numbers.\n    -   \"Poor\" should receive a numerical score of 1\n    -   \"Fair\" should receive a numerical score of 2\n    -   \"Good\" should receive a numerical score of 3\n    -   \"Great\" should receive a numerical score of 4\n    -   \"Excellent\" should receive a numerical score of 5\n\nb)  It would also be helpful to have another column that helps us decide if a score is \"high\" or not.\n\n-   For the sake of this exercise, let's decide that a score of 4 or higher qualifies as a \"high\" score.\n-   Create a new column in the dataset called is_high_review that denotes whether or not the review has a high score or not. In other words, it should be TRUE if review_num is 4 or higher, and FALSE otherwise.\n\n```{r}\nds %<>%\n  mutate(\n    review_num = case_when(review %in% \"Poor\" ~ 1,\n                           review %in% \"Fair\" ~ 2,\n                           review %in% \"Good\" ~ 3,\n                           review %in% \"Great\" ~ 4,\n                           review %in% \"Excellent\" ~ 5),\n    is_high_review = case_when(\n                          review_num >= 4 ~ TRUE,\n                          TRUE ~ FALSE\n    )\n  )\n```\n\n## Task Five\n\n1.  Choose a metric that we will define \"most profitable\" book.\n\n-   Whichever way we choose, we should write down a few notes to ourself to justify our decision and make it clear which method we chose.\n-   One definition of profitable may use the price column, so we can see how much money a book generated. We may also prefer to count the number of books purchased since it could be interpreted as how popular the book is.\n\n2.  For each book, calculate the chosen metric that we chose to measure \"most profitable\" book from the data.\n3.  Investigate the results of our analysis and write out some notes about what books are the most profitable.\n\n### Solution\n\n-   Getting the most profitable book will require to calculate the total number of books in each state\n-   Then multiply the total number of books in that state by the price for a give book\n-   Then adding the number total sales for each book\n\n```{r}\n#| message: false\nsales <- ds %>%\n  group_by(state_clean,book) %>%\n  summarize(frequency=n(),\n            price=mean(price),\n            total_sale=frequency*price)\n```\n\n```{r}\n#| warning: false\n\n\nmost_profitable <- sales %>%\n  group_by(book) %>%\n  summarize(total_sale=sum(total_sale)) %>%\n  arrange(desc(total_sale))\n\n\nmax_sale = max(most_profitable$total_sale)\n\nknitr::kable(most_profitable)\n```\n\n-   `r paste0(\"The most profitable book is\" , most_profitable$book[most_profitable$total_sale ==max_sale])`\n\n## Analysis Considerations\n\nKey Things To Consider in a Data Analysis Report\n\n1.  *Introduction*: What motivated our analysis? What kind of data do we have? What is the main question we're trying to answer?\n2.  *Findings*: What did we need to do to the data to do our analysis? What things are we calculating to answer our main question?\n3.  *Conclusion*: What is the answer to our main question? Was there anything that we feel limits our analysis? What should the reader do with our findings?\n","srcMarkdownNoYaml":"\n\n## Introduction\n\nYou work for a company selling books about learning programming. Your company has produced multiple books, and each has received many reviews. Your company wants us to check out the sales data and see if we can extract any useful information from it. You wil analyze the book_reviews dataset to answer company's important questions.\n\n*Objective of the Analysis*\n\nOur main goal is to figure out **what book is the most profitable**. How will we judge what the \"most profitable\" book is though? Our dataset represents customer purchases. One way to define \"most profitable\" might be to just choose the book that's purchased the most. Another way to define it would be to see how much money each book generates overall.\n\n## Task One\n\n-   Import the dataset\n\n-   Use the `dim()` to find the number of rows and columns\n\n-   Use the `colnames()` to determine the names of the columns in the dataset and take a moment to reflect on what each represents\n\n-   Use a for loop to check column types using `typeof()` function\n\n-   check for unique values using the `unique()`\n\n-   Try yourself first, the press Click Me to see solution!\n\n<details>\n\n<summary>Click Me!</summary>\n\n<p>\n\n*Code for importing the dataset and checking dimensions!*\n\n```{r}\n#| message: false\n#| echo: true\npacman::p_load(\n  readr,\n  dplyr,\n  magrittr\n)\n\nds <- read_csv(\"book_reviews.csv\")\n\ndim(ds)\n\ncolnames(ds)\n```\n\n-   Printing data types using a for loop\n\n```{r}\n for (i in colnames(ds)) {\n   print(typeof(ds[[i]]))\n   \n }\n```\n\n-   Printing unique values for each data type\n\n```{r}\nfor (i in colnames(ds)) {\n  print(unique(ds[[i]]))\n}\n```\n\n</p>\n\n</details>\n\n## Task Two\n\n-   Create a new dataset by removing all rows with `NA`\n-   Check the dimensions of the new cleaned dataset\n\n```{r}\nds <- ds %>%\n  filter(!is.na(review))\ndim(ds)\n```\n\n## Task Three\n\n-   Labels in the state column are inconsistent \"CA\" and California\n-   Make all labels consistent using the mutate function\n\n```{r}\nds <- ds %>%\n  mutate(state_clean = case_when(state %in% \"CA\" ~ \"California\",\n                                  state %in% \"NY\" ~ \"New York\",\n                                  state %in% \"TX\" ~ \"Texas\",\n                                  state %in% \"FL\" ~ \"Florida\",\n                                  TRUE ~ state))\n\nds %>% pull(state_clean) %>% unique()\n```\n\n## Task Four\n\na)  Using the `mutate()` function create a new column in the dataset called review_num. It should take the original review column and convert it into a numerical form. The column should be coded as following:\n\n-   The `case_when()` function might be useful here since we know how each of the reviews should be reclassified into numbers.\n    -   \"Poor\" should receive a numerical score of 1\n    -   \"Fair\" should receive a numerical score of 2\n    -   \"Good\" should receive a numerical score of 3\n    -   \"Great\" should receive a numerical score of 4\n    -   \"Excellent\" should receive a numerical score of 5\n\nb)  It would also be helpful to have another column that helps us decide if a score is \"high\" or not.\n\n-   For the sake of this exercise, let's decide that a score of 4 or higher qualifies as a \"high\" score.\n-   Create a new column in the dataset called is_high_review that denotes whether or not the review has a high score or not. In other words, it should be TRUE if review_num is 4 or higher, and FALSE otherwise.\n\n```{r}\nds %<>%\n  mutate(\n    review_num = case_when(review %in% \"Poor\" ~ 1,\n                           review %in% \"Fair\" ~ 2,\n                           review %in% \"Good\" ~ 3,\n                           review %in% \"Great\" ~ 4,\n                           review %in% \"Excellent\" ~ 5),\n    is_high_review = case_when(\n                          review_num >= 4 ~ TRUE,\n                          TRUE ~ FALSE\n    )\n  )\n```\n\n## Task Five\n\n1.  Choose a metric that we will define \"most profitable\" book.\n\n-   Whichever way we choose, we should write down a few notes to ourself to justify our decision and make it clear which method we chose.\n-   One definition of profitable may use the price column, so we can see how much money a book generated. We may also prefer to count the number of books purchased since it could be interpreted as how popular the book is.\n\n2.  For each book, calculate the chosen metric that we chose to measure \"most profitable\" book from the data.\n3.  Investigate the results of our analysis and write out some notes about what books are the most profitable.\n\n### Solution\n\n-   Getting the most profitable book will require to calculate the total number of books in each state\n-   Then multiply the total number of books in that state by the price for a give book\n-   Then adding the number total sales for each book\n\n```{r}\n#| message: false\nsales <- ds %>%\n  group_by(state_clean,book) %>%\n  summarize(frequency=n(),\n            price=mean(price),\n            total_sale=frequency*price)\n```\n\n```{r}\n#| warning: false\n\n\nmost_profitable <- sales %>%\n  group_by(book) %>%\n  summarize(total_sale=sum(total_sale)) %>%\n  arrange(desc(total_sale))\n\n\nmax_sale = max(most_profitable$total_sale)\n\nknitr::kable(most_profitable)\n```\n\n-   `r paste0(\"The most profitable book is\" , most_profitable$book[most_profitable$total_sale ==max_sale])`\n\n## Analysis Considerations\n\nKey Things To Consider in a Data Analysis Report\n\n1.  *Introduction*: What motivated our analysis? What kind of data do we have? What is the main question we're trying to answer?\n2.  *Findings*: What did we need to do to the data to do our analysis? What things are we calculating to answer our main question?\n3.  *Conclusion*: What is the answer to our main question? Was there anything that we feel limits our analysis? What should the reader do with our findings?\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"book_reviews.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.545","title":"Analyzing Book Reviews","author":"Castory Munishi","date":"10/25/2022","editor":"visual"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}