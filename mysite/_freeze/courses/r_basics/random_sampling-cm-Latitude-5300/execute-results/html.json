{
  "hash": "27de33aba50107083b562cb80ae690e4",
  "result": {
    "markdown": "---\ntitle: \"Simple Random Sampling\"\nauthor: \"Castory Munishi\"\ndate: 11/04/2022\nexecute: \n  echo: true\n  warning: false\nformat: \n    revealjs:\n      code-fold: true\neditor: visual\n---\n\n\n## Loading the dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(\n  readr,\n  dplyr,\n  tibble,\n  ggplot2\n)\n\nds <- read_csv(\"datasets/wnba.csv\")\n```\n:::\n\n\n-   The dataset description [wnba dataset at kaggle](https://www.kaggle.com/datasets/jinxbe/wnba-player-stats-2017)\n\n## Sampling Error\n\n-   In sampling we target to use samples to explain population parameters\n-   Different samples will give different estimates of population parameters\n-   The difference between population parameters and sample estimates is known as *sampling error*\n-   Statistics - sample summaries\n-   Parameters - population summaries\n\n> sampling error = parameter - statistic\n\n## Getting a sample from a dataset\n\n+ use the `sample()` function\n\n`sample(df$col, size=n)`\n\n+ `set.seed()` is used to make random sampling reproducible\n\n## Task 1\n\ni. Find the maximum number of games played in the whole dataset `parameter`\nii. Use the `sample()` to random sample 30 players `sample`\niii. Find the maximum number of games played in the sample `statistic`\niv. Calculate the sampling error `sampling_error`\n\n## Solution 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparameter <- max(ds$Games_Played, na.rm = T)\n\nset.seed(1)\nsample <- sample(ds$Games_Played,30)\n\nstatistic <- max(sample, na.rm = T)\n\nsampling_error = parameter - statistic\n```\n:::\n\n\n## Representative Sample\n\n+ Samples with a small sampling error are considered representative\n\n![](images/Samples.svg)\n\n\n+ The sample should be selected randomly from the population.\n\n\n## Random Sample\n\n+ Every individual has an equal chance of being picked.\n+ Can be archived by generating random numbers and use them to pick individuals from the population\n\n![](images/s1m1_Simple_random_sampling_v2.svg)\n\n## Sampling with(out) Replacement\n\n+ Using the `sample()` can extract samples from a dataset with or without replacement\n+ The default is `replace = FALSE`\n+ A particular sample can not be drawn more than once during a sampling event\n\n\n## `sample_n()` function\n\n+ From `dplyr` package\n+ Can be used to sample rows from multiple columns\n+ Unlike the `sample()` which samples observations from a single column (vector)\n\n## `set.seed()` function\n\n+ Uses a *pseudorandom number generator*\n\n>  pseudorandom number generator uses an initial value to generate a sequence of numbers that has properties similar to those of a sequence that is truly random. The purpose of this is to start a random sequence that can be reproduced later.\n\n+ When you use `set.seed()` you will get same results repeatedly.\n\n## Base r `replicate()` function\n\n+ Used for repeated evaluation of an epression\n\n+ `replicate(n,expr)`\n\n+ `expr` is a function call or formula\n\n## Replicate 100 samples\n\n![](images/replicate.svg)\n\n## Task 2\n\nGenerate a vector of 100 random sample means for the PTS column, with a sample size of 10.\n\n  1. Set the random seed to 1.\n  2. Use `replicate()` to generate a vector of 100 random sample means of sample size 10.\n      - Save the results of the analysis as mean_points.\n  3. Calculate the minimum value of mean_points, and save as minimum.\n  4. Calculate the maximum value of mean_points, and save as maximum.\n    \n## Solution 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n# Mean for one sample\nmean(sample(ds$PTS,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 171.4\n```\n:::\n\n```{.r .cell-code}\n# Mean for 100 samples\nsample_means <- replicate(100,mean(sample(ds$PTS,10)))\n\nminimum <- min(sample_means)\nmaximum <- max(sample_means)\n```\n:::\n\n\n## Visualizing the sample_means\n\n\n::: {.cell animation.hook='gifski'}\n\n```{.r .cell-code}\nx <- 1:100\n\ndf <- tibble(x,sample_means)\n\nggplot(data = df, \n       aes(x = x, y = sample_means )) +\n    geom_point() +\n    geom_hline(yintercept = mean(ds$PTS), \n    color = \"blue\") +\n    ylim(90, 310)+\n   theme_classic()\n```\n\n::: {.cell-output-display}\n![](random_sampling-cm-Latitude-5300_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Remarks\n\n+ we can see that the sample means vary a lot around the population mean. \n\n![](images/Graphic_1.png)\n\n\n## Remarks\n\n+ Because of the high variation, there is a good chance we get a sample mean that is not representative of the population.\n\n![](images/Graphic_2.png)\n\n\n## Remarks\n\n+ Increasing the sample size addresses the problem\n+ Increasing the sample size the sample means vary less\n+ Chances of getting unrepresentative sample decreases\n\n\n## Remarks\n\n![](images/grid.png)\n\n## Remarks\n\n> Simple random sampling isn't a reliable sampling method when the sample size is small. Because sample means vary a lot around the population mean, there's a good chance we'll get an unrepresentative sample\n\n> When we do simple random sampling, we should try to get as large a sample as possible. A large sample decreases the variability of the sampling process, which, in turn, decreases the chances that we'll get an unrepresentative sample\n\n## Remarks\n\n![](images/Graphic_3.png)",
    "supporting": [
      "random_sampling-cm-Latitude-5300_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}